<script>
	class QRReader {

		constructor() {
			this.active = false;
			this.webcam = null;
			this.canvas = null;
			this.ctx = null;
			this.decoder = null;
			this.constraints = null;
		}

		setCanvas() {
			this.canvas = document.createElement("canvas");
			this.ctx = this.canvas.getContext("2d");
		}

		init(webcam) {
			var template = document.currentScript.ownerDocument.querySelector("template");
			console.log(template.baseURI);
			const baseurl = "/src/components/qr-code/";
			let streaming = false;

			// Init Webcam + Canvas
			this.webcam = webcam;
			//this.webcam = document.querySelector("video");

			this.setCanvas();
			this.decoder = new Worker(baseurl + "decoder.min.js");

			// Resize webcam according to input
			this.webcam.addEventListener("play", (ev) => {
				if (!streaming) {
					this.setCanvasProperties();
					streaming = true;
				}
			}, false);

			navigator.mediaDevices.enumerateDevices()
				.then((devices) => {
					const device = devices.filter((device) => {
						const deviceLabel = device.label.split(',')[1];
						if (device.kind == "videoinput") {
							return device;
						}
					});

					if (device.length > 1) {
						this.constraints = {
							video: {
								mandatory: {
									sourceId: device[1].deviceId ? device[1].deviceId : null
								}
							},
							audio: false
						};

					} else if (device.length) {
						this.constraints = {
							video: {
								mandatory: {
									sourceId: device[0].deviceId ? device[0].deviceId : null
								}
							},
							audio: false
						};

					} else {
						this.constraints = { video: true };
					}
				})
				.catch((error) => {
					this.showErrorMsg();
					console.error("Error occurred : ", error);
				});

		}

		showErrorMsg() {
			document.querySelector('.custom-btn')
				.style.display = "none"; //Hide scan button, if error
			// snackbar.show('Unable to open the camera, provide permission to access the camera', 5000);
		}

		stopCapture() {
			if (this.webcam && this.webcam.srcObject) {
				// TODO clean reset
				//this.webcam.pause();
				//this.webcam.srcObject.stop();
				this.webcam.srcObject = null;

			}
		}

		startCapture() {
			navigator.mediaDevices.getUserMedia(this.constraints)
				.then((stream) => {
					//this.webcam.play();
					this.webcam.srcObject = stream;
				})
				.catch((err) => {
					console.error("Error occurred ", err);
					showErrorMsg();
				});
		}

		setCanvasProperties() {
			this.canvas.width = window.innerWidth;
			this.canvas.height = window.innerHeight;
		}

		scan(callback) {
			this.active = true;
			this.setCanvas();
			this.decoder.onmessage = (event) => { this.onDecoderMessage(event, callback) };

			// Start QR-decoder
			this.newDecoderFrame();
		}

		onDecoderMessage(event, callback) {
			if (event.data.length > 0) {
				const qrid = event.data[0][2];
				this.active = false
				callback(qrid);
			}
			setTimeout(this.newDecoderFrame.bind(this), 0);
		}

		newDecoderFrame() {
			if (!this.active) {
				return;
			}
			try {
				this.ctx.drawImage(this.webcam, 0, 0,
					this.canvas.width, this.canvas.height);
				const imgData = this.ctx.getImageData(0, 0, this.canvas.width,
					this.canvas.height);

				if (imgData.data) {
					this.decoder.postMessage(imgData);
				}
			} catch (e) {
				// Try-Catch to circumvent Firefox Bug #879717
				if (e.name == "NS_ERROR_NOT_AVAILABLE") {
					setTimeout(this.newDecoderFrame.bind(this), 0)
				};
			}
		}
	};

</script>
